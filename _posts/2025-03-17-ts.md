## 1.TS的完整定义，环境搭建

首先新建项目，安装TS

```bash
npm init -y

# 安装TS
npm i typescript -D

# 生成TS配置文件
npx tsc --init
```

TS的优势：

- 编译的时候静态检测：当函数或者方法传参或者变量赋值不匹配的时候，会出现类型错误，规避了大量的低级错误。

  ```ts
  let str: string = "abc"
  str = 3 // 不能将类型“number”分配给类型“string”。
  
  let arr:number[] = [3,4,5,"1"] // 不能将类型“string”分配给类型“number”。
  
  let arr: string = "abc"
  arr.forEach(ele => console.log(ele)); // 类型“string”上不存在属性“forEach”。
  ```

- 代码提示更加明确。

- 引入了泛型和一系列的TS特有的类型。

- 强大的 `d.ts`声明文件：`d.ts`文件就像一个目录一样，清晰的展示了依赖文件的接口，`type`类型，类，函数，变量等声明。

- 轻松编译成JS文件：尽管TS文件有错误，但是大多数情况也能编译出JS文件。

- 灵活性高：TS是一门强类型检查语言，但是也有`any`类型和`as any`断言。 



## 2.类型注解，类型推导

**类型注解**

```ts
interface Student {
    name: string;
    age: number;
}

// 这里限制了stuObj的属性，必须要有name和age，且name要为string，age要为number，少写或者写错了都会有错误提示
let stuObj: Student = {
    name: "zs"
}
```

![](https://image.xukucha.cn/blog/20250308192742.png)



**类型推导**

```ts
let a = 1
a = 'abc'

// 虽然没有定义变量a的类型，但是TS自动推导出了a的类型为number，当给a赋值'abc'的时候就会有错误提示
```

![](https://image.xukucha.cn/blog/20250308193025.png)



## 3.常用的TS类型

**基本类型：**

number  string  boolean  symbol  null  undefined

**根类型：**

Object  {}

**对象类型：**

Array  object  function

**枚举：**

enum

**其他：**

any  unknown  never  void 元组  可变元组

**合成类型：**

- 联合类型

  ```ts
  // 相当于或，可以让一个变量拥有多个类型
  
  let a: number | string | boolean
  a = 1
  a = 'abc'
  a = true
  ```

- 交叉类型

  ```ts
  type Obj1 = { name: string }
  type Obj2 = { age: number }
  
  // 这里person的类型相当于{name: string,age: number}
  let person: Obj1 & Obj2 = {
      name: 'zs',
      age: 18
  }
  ```

**字面量类型：**

```ts
// 用值当类型，就限定了只能只能有这几个值

type num = 1 | 2 | 3
let a: num = 1
```



## 4.枚举

数字枚举

```ts
// number类型的枚举
enum Week {
    Monday = 1,
    Tuesday,
    Wensday,
    ThirsDay,
    Friday,
    Sarturday,
    Sunday
}

// 可以看的出数字枚举TS会自动推断出Friday的值为5。
console.log(Week.Friday);// 5
// 数字枚举不仅可以通过key取值，还能通过值取key
console.log(Week[5]);// Friday
```

字符串枚举

```ts
enum Week {
    Monday = "MyMonday",
    Tuesday = "MyTuesday",
    Wensday = "Wensday",
    ThirsDay = "ThirsDay",
    Friday = "Friday",
    Sarturday = "Sarturday",
    Sunday = "sunday"
}

// 字符串类型的枚举不能推断出值
console.log(Week.ThirsDay); // ThirsDay
// 字符串类型枚举不能通过值取key
console.log(Week["MyMonday"]); // 会报错
```



## 5.any,unknow的区别和应用场景

**相同点：**`any`和`unknow`可以是任何类的父类，所以任何变量都可以赋值给`any`或者`unknow`。

**不同点：**

1. `any`也可以是任何类的子类，但是`unknow`不可以，所以`any`可以赋值给其他类型的变量。

   ```ts
   // num是number，data是any，但是可以把num赋值给data
   let num: number = 1
   let data: any = num
   
   // data2是any，但是可以把data2赋值给num2
   let data2: any = 123
   let num2: number = data2
   ```

2. 不能拿`unknow`类型的变量来获取任何属性和方法，但是`any`类型可以。



## 6.接口和为什么用接口

**接口：**一种定义对象类型的类型。

```ts
// 定义了一个Person接口，如果某个对象是Person类型，那么他就要有name属性和age属性，且还分别定义了两个的属性值类型。
interface Person {
    name: string;
    age: number
}
```

为什么使用接口：

1. 方便继承

   ```ts
   // 定义了宠物接口
   interface Pet {
       name: string;
       age: number;
   }
   
   // 这个时候想写一个狗狗接口，但是不想写重复的代码，就可以使用继承
   interface Dog extends Pet {
       like: string
   }
   
   const dog1: Dog = {
       name: "zs",
       age: 3,
       like: "meet"
   }
   ```

2. 为多个同类别的类提供统一的方法和属性声明

   ```ts
   // 定义了宠物接口
   interface Pet {
       name: string;
       age: number;
   }
   
   // 这个时候想写一个狗狗接口，但是不想写重复的代码，就可以使用继承
   interface Dog extends Pet {
       like: string
   }
   
   // implements:实现、实施
   class Hashiqi implements Dog {
       like: string;
       name: string;
       age: number;
   }
   ```

   ![](https://image.xukucha.cn/blog/20250309234454.png)



## 7.可索引签名

有的时候写好了一个`interface`，但是不知道将来会不会有新的属性加入，又不想出现报错，这个时候就可以使用可索引签名。

```ts
// 定义了宠物接口

interface Pet {
    name: string;
    age: number;
    [x: string]: any
}

// 发现加上了like和desc属性，都没有出现错误提示，就是因为[x: string]: any
// 而且大部分情况都是写成[x: string]，这样写无论属性是number还是string或者Symbol都不会出现错误，可以自己尝试
const dog: Pet = {
    name: "zs",
    age: 3,
    like: "meet",
    desc: "xxxxx"
}

```



## 8.索引访问类型

这里使用了泛型，泛型详见 26.泛型的约束

```ts
const symid = Symbol('productid')

interface Product {
    [symid]: number
    name: string
    age: number
    price: number
}

// 通过这种方式可以获取到属性值的类型
type A = Product["price"] // number
type B = Product['name'] // string

// 但是要获取symid属性值的类型则需要其他的方式，因为symid是一个变量
type C = Product[typeof symid] // number


// 获取一个接口中所有的key
type PKeys = keyof Product // "name" | "age" | "price" | typeof symid
let pKeys: PKeys = "name"
```

![](https://image.xukucha.cn/blog/20250310001454.png)



## 9.null和undefined

```ts
// 定义的时候要想表示一个值可能为undefined可以写
let str: string | undefined


// 一个方法表示可能会接受undefined可以写?:
function fn(data?: string) {
    data.charAt
}

// any,unknown,undefined 可以接受 undefined
// any,unknown,null 可以接受 null
let data: unknown = undefined
```

![](https://image.xukucha.cn/blog/20250310003259.png)



## 10.TS函数和TS函数类型

```ts
// 可以限制函数的参数的类型，以及返回值的类型
// 其实不写返回值的类型，也能自动推导出来
function fn1(a: string, b: string): number {
    console.log(a);
    console.log(b);
    return 3
}

// 另一种写法
const fn2 = function (a: string, b: string): number {
    console.log(a);
    console.log(b);
    return 3
}

// 还可以这样写
type TypeFn = (a: string, b: string) => number
const fn3: TypeFn = function (a, b) {
    console.log(a);
    console.log(b);
    return 3
}

// 当不确定是否还有其他参数的时候
const fn4 = (a: string, b: string, ...rest: any) => {
    console.log(a);
    console.log(b);
    console.log(rest);
}
```



## 11.interface和type的区别

`type`和`interface`类似，都是来定义类型的，但是他两还是有区别的：

1. `interface`只能定义对象类型或者接口当名字的函数类型；`type`可以定义任何类型，包括基础类型、联合类型、交叉类型、元组。

   ```ts
   
   // 定义基本类型
   type Typebase1 = number
   
   // 定义联合类型
   type Typebase2 = string | number | boolean
   
   interface Car {
       brand: string
   }
   interface Plane {
       id: string
       name: string
   }
   type Typebase3 = Car | Plane
   
   // 定义元组
   type Typebase4 = [Car, Plane]
   
   ```

2. 接口可以`extends`一个或者多个接口，也可以继承`type`，但是`type`类型没有继承功能。

3. 用`type`交叉类型可以让类型中的成员合并成一个新的`type`，但是`interface`不能交叉合并。

   ```ts
   type Cat1 = {
       name: string
   }
   
   type Cat2 = {
       age: number
   }
   
   type Cat3 = Cat1 & Cat2
   
   const mimi: Cat3 = {
       name: 'zs',
       age: 3,
   }
   ```

   如果使用`interface`想实现类似交叉合并的效果，可以这样写：

   ```ts
   // 先写了一个Cat接口，里面定义了一个属性
   interface Cat {
       name: string
   }
   
   // 又写了一个Cat接口，里面定义了另一个属性
   interface Cat {
       age: number
   }
   
   // 那么最终Cat接口就合并了，里面定义了两个属性，name和age
   const mimi: Cat = {
   
   }
   ```



## 12.元组

1. 在定义的时候每个元素的类型都确定
2. 元素值的数据类型必须是当前元素定义的类型
3. 元素值的个数必须和定义时的个数相同

```ts
// 这样类型的一个数组就叫元组
const list: [string, number, boolean] = ['abc', 1231, true]
```



## 13.TS数组和数组元素怎么同时为只读

```ts

// 我们可以改变数组中的元素
const list = [1, 2, 3, 5, 6, 8]
list[0] = 2

// 但是如果加上as const，这样就能让数组中每个元素变为只读
const list2 = [1, 2, 35, 8] as const
list2[1] = 2 // 无法为“1”赋值，因为它是只读属性。
```



## 14.可变元组的应用

```ts
// 可变元组
// 前面是固定的，但是后面通过 ...any[]可以任意扩展后面的元素
const list: [string, string, number, ...any[]] =
    ['abc', 'def', 123, true, false, 'wer']

// 为了代码更加清晰易懂，还可以给每个类型加上tag，提高易读性
const list: [name: string, title: string, age: number, ...rest: any[]] =
    ['abc', 'def', 123, true, false, 'wer']
```



## 15.类，静态属性

**什么是类？**

类就是拥有相同属性和方法的一系列对象的集合。

```ts
// 定义了People这样一个类，有name,age,addr属性，还有doEat,doStep方法
class People {
    name: string
    age: number
    addr: string

    // static表示静态属性，简单来说就是这个属性是属于类的
    static count: number = 10

    constructor(_name: string, _age: number, _addr: string) {
        this.name = _name
        this.age = _age
        this.addr = _addr
    }
    doEat() { }
    doStep() { }
}

const p1 = new People('zs', 18, 'sz')
// p1无法访问到静态属性
p1.count // 会报错，并提示访问静态属性要用类访问

console.log(People.count); // 10
```



## 16.项目中如何使用类的静态属性

```ts

// 比如在一个工具类中写很多不同的格式化日期的方法
class Util {
    static formatDate() { }
    static diffDatebyDay() { }
    static diffDateByHour() { }
}

// 调用的时候比较清晰，通过Util.来调用这些方法
Util.formatDate()
Util.diffDatebyDay()
Util.diffDateByHour()

```



## 17.TS的单例模式

```ts
class Util {
    static dateUtil = new Util()
    // private表示私有的，只能在类中调用，所以在外部想用new创建一个实例会报错
    private constructor() {

    }
    formatDate() { }
    diffDatebyDay() { }
    diffDateByHour() { }
}

const dataUtil = new Util() // 报错提示：类“Util”的构造函数是私有的，仅可在类声明中访问。

// 那这个时候我们想用类中的方法就不能new一个实例来调用了，只能通过访问类中的dateUtil来调用
const dateUtil1 = Util.dateUtil
const dateUtil2 = Util.dateUtil
console.log(dateUtil1 === dateUtil2); // true
```

```ts
// 上面那种方式，会在类中直接创建一个实例，不管我们是否需要调用方法，这样会浪费一些内存空间

class Util {
     // 这里的类型表示dateUtil的类型是Util的实例
    static dateUtil: Util

    // 写一个静态方法，决定是否创建一个Util的实例
    static getInstance() {
        if (!this.dateUtil) {
            this.dateUtil = new Util
        }
        return this.dateUtil
    }

    // private表示私有的，只能在类中调用，所以在外部想用new创建一个实例会报错
    private constructor() {
    }

    formatDate() { }
    diffDatebyDay() { }
    diffDateByHour() { }
}

const dateUtil1 = Util.getInstance()
const dateUtil2 = Util.getInstance()
console.log(dateUtil1 === dateUtil2); // true

```



## 18.TS类中的getter 和 setter

```ts
// 如果现在要实例化这个People类，随便传入age肯定是不合适的，我们需要做一些处理
class People {
    name: string
    // !:可以忽略不用给初始值
    _age!: number

    // 在constructor去做传入age的处理，会显得十分的混杂
    constructor(_name: string) {
        this.name = _name
    }

    // 使用一个方法来设置age，
    set age(val: number) {
        if (val < 0) {
            console.log("传入的age不合法");
        }
        this._age = val
    }

    get age() {
        return this._age
    }

}
```



## 19.TS的静态成员，方法拦截器的实战

假如说我们要对实例的一个方法做一个拦截，我们可以怎么实现呢？0

```ts
class People {
    name: string
    age: number
    constructor(_name: string, _age: number) {
        this.name = _name
        this.age = _age
    }
    doEat(who: string, where: string) {
        console.log(`和${who}一起在${where}吃饭`);
    }
    doStep() { }
}

// 是 JavaScript 的一个内置方法，用于获取一个对象上某个属性的详细描述（属性描述符）。
// 这个方法让我们能够检查对象属性的特性，例如它是否可写、可枚举、可配置，以及它的值或者 getter/setter 函数。
const dataProp = Object.getOwnPropertyDescriptor(People.prototype, 'doEat')

// dataProp.value指向原来的方法
// 使用一个变量储存原来的指向
const targetMethod = dataProp?.value
// 然后把value指向一个新的方法
dataProp!.value = function (...args: any[]) {
    console.log('===前置拦截');
    targetMethod.apply(this, args)
    console.log('===后置拦截===');
}

Object.defineProperty(People.prototype, 'doEat', dataProp!)

const p = new People('zs', 18)

p.doEat('朋友', '龙华')
// 输出结果是:
// ===前置拦截
// 和朋友一起在龙华吃饭
// ===后置拦截===
```



## 20.tsconfig.json

```ts
{
    "compilerOptions":{...} 
	"include": [], // 表示配置对哪些文件生效 例如 ["src/**/*","tests/**/*"]
  	"exclude": [], // 表示排除哪些文件，配置对这些文件不生效 例如 ["node_modules","dist","**/*.test.ts"]
	"extends":""   // 继承另一个配置文件 例如 "./tsconfig.base.json"
}
```



## 21.TS底层实现继承的方式

底层是使用了寄生组合式继承的方式，自行了解寄生组合式继承。

```ts
// 在继承的子类中，super的用法
// 1.表示父类构造犯法
// 2.调用父类中的方法或者属性

class Pay {
    constructor(bank_card_no: string, balance: number, cost: number, tokenid: string) {
        this.balance = balance
        this.bank_card_no = bank_card_no
        this.cost = cost
        this.tokenid = tokenid
    }
    bank_card_no: string
    balance: number
    cost: number
    tokenid: string

    log() {
        console.log('===父类打印log===', this.bank_card_no);
    }

}

class MobilePay extends Pay {
    constructor(
        bank_card_no: string,
        balance: number,
        cost: number,
        tokenid: string,
        type: number,
        change: number,
        openid: string,
        appid: string) {
        super(
            bank_card_no,
            balance,
            cost,
            tokenid,
        )
        this.type = type
        this.change = change
        this.openid = openid
        this.appid = appid
    }
    type: number
    change: number
    openid: string
    appid: string

    log() {
        // 父类中的log方法不能满足需求，我们需要改写的话就要使用super，super可以调用父类中的方法或者属性
        super.log()
        console.log('===子类打印log===');
    }
}

const wxPay = new MobilePay("123", 321, 999, "asdfasdf123213", 1, 23, "asdfadsf45645", "546512112312")
wxPay.log()
```



## 22.类型断言

使用`as`告诉TS这个数据是什么类型

```ts
const data: unknown = { name: "Alice" };
const user = data as { name: string }; // 断言 data 是对象

function formatInput(input: string | number) {
  // 假设我们知道此时 input 是 string
  const strInput = input as string;
  return strInput.trim();
}
```

需要注意的是类型断言不是类型转换

```ts
const num: any = "123";
const numValue = num as number; // 编译通过，但运行时 numValue 仍是字符串！
console.log(typeof numValue); // 输出 "string"
```



## 23.类型守卫

有好几种形式：

`typeof`类型守卫

```ts
function printValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase()); // 类型被收窄为 string
  } else {
    console.log(value.toFixed(2));    // 类型被收窄为 number
  }
}
```

`instanceof`类型守卫

```ts
// 检查对象是否是某个类的实例：
class Dog { bark() {} }
class Cat { meow() {} }

function handleAnimal(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark(); // 类型收窄为 Dog
  } else {
    animal.meow(); // 类型收窄为 Cat
  }
}
```

`in`操作符守卫

```ts
interface Bird {
  fly(): void;
}

interface Fish {
  swim(): void;
}

function move(animal: Bird | Fish) {
  if ("fly" in animal) {
    animal.fly(); // 类型收窄为 Bird
  } else {
    animal.swim(); // 类型收窄为 Fish
  }
}
```

自定义类型谓词
```ts
// 类型谓词是一个返回值为 value is Type 的函数，其中：
// value 是函数的参数。
// Type 是你希望收窄的类型。
function isString(value: unknown): value is string {
    return typeof value === "string";
}

function printValue(value: unknown) {
    if (isString(value)) {
        // 这个时候鼠标悬浮在value上就可以看到value的类型是string了
        console.log(value.toUpperCase());
    } else {
        console.log("不是字符串");
    }
}
```



## 24.泛型

泛型也是一种数据类型，有以下特点：

**特点一：**定义时不明确使用时必须明确某种具体数据类型的数据类型。

**特点二：**编译期间进行数据类型检查的数据类型。

```ts
// 定义这个接口的时候，并不知道value属性是什么类型，就用一个参数代替
interface Ref<T> {
    value: T
}

// 定义的时候不明确，但是使用的时候就要明确，需要传入一个类型
let ref: Ref<string> = {
    value: "string"
}
```



## 25.泛型的默认值

```ts
// 在定义的时候使用等号赋予一个默认值，这样当不传入类型的时候用的就是默认值
interface Ref<T=number> {
    value: T
}

let ref: Ref = {
    value: 123
}
```



## 26.泛型的约束

使用`extends`来约束传入的泛型

```ts
// T 必须包含 length 属性
function getLength<T extends { length: number }>(arg: T): number {
    return arg.length;
}

// 有效调用
getLength("string");       // 字符串有 length 属性
getLength([1, 2, 3]);      // 数组有 length 属性
getLength({ length: 10 }); // 对象明确有 length 属性

// 无效调用
// getLength(123);  // 错误：数字没有 length 属性
```



## 27.反向推断泛型

TS能自动推断出泛型的类型。

```ts
// 标准泛型使用方式
function identity<T>(arg: T): T {
    return arg;
}

// 显式指定泛型类型
const result = identity<string>("hello");
```

```ts
// 写一个快速排序的方法来举例
const quickSort = <T>(arr: T[]): T[] => {
    if (arr.length <= 1) return arr

    const pivot = arr[0]

    const left: T[] = []
    const right: T[] = []

    for (let index = 1; index < arr.length; index++) {
        if (arr[index] < pivot) {
            left.push(arr[index])
        } else {
            right.push(arr[index])
        }
    }
    return [...quickSort(left), pivot, ...quickSort(right)]
}

// 这里并没有指定T的类型，但是TS自动推断出了T为number
console.log(quickSort([4564, 21, 21231, 3.0151]));

```



## 28.函数重载

函数重载的基本结构是：先声明多个函数签名（不包含实现），然后提供一个实现签名（通常使用更宽泛的类型）来处理所有情况。

```ts
// 函数重载签名
function add(a: number, b: number): number
function add(a: string, b: string): string

// 实现签名（必须兼容所有重载签名）
function add(a: number | string, b: number | string) {
    if (typeof a === "number" && typeof b === "number") {
        return a + b
    }
    if (typeof a === "string" && typeof b === "string") {
        return a + b
    }
}

// 使用：
const num = add(1, 2);       // 返回类型是 number
const str = add("Hello, ", "World");  // 返回类型是 string
```

```ts
// 创建箭头函数并指定其类型为 AddFunction

type AddFunction = {
  (a: number, b: number): number;
  (a: string, b: string): string;
};

const add: AddFunction = (a: any, b: any): any => {
  if (typeof a === "number" && typeof b === "number") {
    return a + b;  // 返回数字之和
  }
  if (typeof a === "string" && typeof b === "string") {
    return a + b;  // 返回字符串拼接结果
  }
  throw new Error("Parameters must be numbers or strings");
};

// 使用：
const num = add(1, 2);       // 返回类型是 number
const str = add("Hello, ", "World");  // 返回类型是 string
```



## 29.交叉类型

```ts
type T1 = { a: string, b: number }
type T2 = { c: string, d: number }

// T4 = { a: string, b: number, c: string, d: number }
type T4 = T1 & T2

const obj: T4 = {
    a: 'asdf',
    b: 123,
    c: '123',
    d: 789
}
```

