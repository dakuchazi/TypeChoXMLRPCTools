---
title: web3学习笔记(三)
categories: [web3]
tags: [区块链]
---

# web3学习笔记(三)

主要是学习solidity基础，学习WTF中Solidity 101前三节

WTF传送门：[https://www.wtf.academy/zh/course](https://www.wtf.academy/zh/course)

开发工具Remix：[https://remix.ethereum.org](https://remix.ethereum.org)



## 4.函数输出

### 4.1.返回值：return 和 returns

主要的意思就是Solidity中，函数里面用`return`表示要返回什么，函数名后面用`returns`表示返回的类型（有点TS那味道了）。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

contract HelloWeb3 {
    string public _string = "Hello Web3!";

    // 返回多个变量
    // public 内部外部均可见
    // pure上一篇讲过了，表示不能修改也不能读取这里面的变量，比如 _string
    // uint256 u表示无符号 int表示整型 256表示256位
    // bool 布尔类型
    // uint256[3] uint256的数组，里面有三个元素
    // memory 数组类型返回值默认必须用memory修饰后面章节再学
    function returnMultiple() public pure returns(uint256, bool, uint256[3] memory){
    	// 这里如果写 [1,2,5]的话，会默认为uint8[3]，所以第一个元素写uint256(1)，相当于强制转换了
        return(1, true, [uint256(1),2,5]);
    } 
}
```

### 4.2.命名式返回

这里我理解的就是可以在`returns`中写明了要返回哪些变量，这样函数里面就不用写`return`了。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

contract HelloWeb3 {
    string public _string = "Hello Web3!";

    // 命名式返回
    // 个人觉得这样看起来舒服一点了
    function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array){
        _number = 2;
        _bool = false;
        _array = [uint256(3),2,1];
    }
    
    // 命名式返回，依然支持return
    // 当然喜欢return的依然可以return，感觉多此一举，干嘛没事找事
    function returnNamed2() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array){
        return(1, true, [uint256(1),2,5]);
    }
}
```

### 4.3.解构式赋值

这个又跟JS很像了，不过要注意类型，不然就会报错。个人建议还是按照顺序写，把变量名都对应上。
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

contract HelloWeb3 {
    string public _string = "Hello Web3!";

    function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array){
        _number = 2;
        _bool = false;
        _array = [uint256(3),2,1];
    }
    
    function readReturn2() public pure {
        uint256 _number;
        bool _bool;
        uint256[3] memory _array;
        // 这样写会报错，因为类型不符合，所以说按顺序写，这样不容易弄错
        ( _bool,_number, _array) = returnNamed();
    }
    
    function readReturn() public pure {
        uint256 _number;
        bool _bool;
        uint256[3] memory _array;
        (_number, _bool, _array) = returnNamed();
        // 也可以只结构其中一个，用逗号隔开
        // (, _bool, ) = returnNamed();
    }
}
```



## 5.变量数据存储和作用域

有点上强度了，云里雾里的，只能靠着和JS进行比对来理解。

**引用类型(Reference Type)** ：包括数组（`array`）和结构体（`struct`），由于这类变量比较复杂，占用存储空间大，我们在使用时必须要声明数据存储的位置。



### 5.1.数据位置

Solidity数据存储一共有3种：`storage`，`memory`和`calldata`

`storage`储存在链上他是最烧钱的(`gas`消耗多)；`memory`和`calldata`储存在内存中，烧钱少一点。

**storage**：

- 这是状态变量的默认存储位置
- 存储在区块链上（on-chain）
- 数据永久保存在合约中
- 使用 `gas `成本较高，因为写入区块链需要消耗更多资源

**memory**：

- 主要用于函数参数和临时变量
- 存储在内存中，不存储在区块链上
- 仅在函数执行期间存在，函数执行完毕后释放
- 比 `storage `消耗的 `gas `少
- 可以修改数据

**calldata**：

- 类似于 `memory`，存储在内存中而非区块链上

- 与 `memory `的主要区别是 `calldata `变量是只读的，不能被修改

- 通常用于外部函数参数（例如使用 `external `可见性修饰符的函数）

- 是最节省 `gas `的数据位置选项

  ![](https://image.xukucha.cn/blog/20250408205341.png)

**这里要吐槽文档中有一句关于`memory`的介绍：“尤其是如果返回数据类型是变长的情况下”，根本就不明白什么叫“变长”。。。。**
“变长”指的是那些长度不固定的数据类型，比如`string`、`bytes`、`array`、`struct`，在使用这些数据类型的时候，必须要使用`memory`。

知道了“变长”的数据类型，那不变长的数据类型有哪些？`uint`、`address`、`bool`等这些数据长度固定，就不用`memory`。



### 5.2.变量作用域

`Solidity`中变量按作用域划分有三种，分别是状态变量（state variable），局部变量（local variable）和全局变量(global variable)

#### 5.2.1.状态变量

状态变量大概就是在合约内定义的变量，状态变量是上链的，所有合约内的函数都能访问，也就说最烧钱的一个。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

contract HelloWeb3 {
    string public _string = "Hello Web3!";
    uint public x = 1;
    uint public y;
    string public z;
    
    // 刚好复习一下 
    // external：外部的 只能从合约外部访问（但内部可以通过 this.f() 来调用，f是函数名）。
    function foo() external{
        // 可以在函数里更改状态变量的值
        x = 5;
        y = 2;
        z = "0xAA";
    }
}
```

#### 5.2.2.局部变量

在函数内定义的变量就是局部变量，烧钱稍微好一点。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

contract HelloWeb3 {
    string public _string = "Hello Web3!";

    // 刚好复习一下 
    // pure标记的函数，不能读取也不能修改状态变量 _string
    function bar() external pure returns(uint){
        uint xx = 1;
        uint yy = 3;
        uint zz = xx + yy;
        return(zz);
    }
}
```

#### 5.2.3.全局变量

全局变量是`solidity`预设的，也就是说可以直接使用：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

contract HelloWeb3 {
    function global() external view returns(address, uint, bytes memory){
        address sender = msg.sender;
        uint blockNum = block.number;
        bytes memory data = msg.data;
        return(sender, blockNum, data);
    }
}
```

在上面例子里，我们使用了3个常用的全局变量：`msg.sender`，`block.number`和`msg.data`，他们分别代表请求发起地址，当前区块高度，和请求数据。下面是一些常用的全局变量，更完整的列表请看这个[链接](https://learnblockchain.cn/docs/solidity/units-and-global-variables.html#special-variables-and-functions)。

卧槽这就有点多了，用的时候再看吧，死记硬背肯定不行。

#### 5.2.4.全局变量-以太单位与时间单位

以太单位：

`Solidity`中不存在小数点，以`0`代替为小数点。

- `wei`: 1
- `gwei`: 1e9 = 1000000000
- `ether`: 1e18 = 1000000000000000000

坏了，这tm的又看不懂了，这是干什么啊。



时间单位：

- `seconds`: 1
- `minutes`: 60 seconds = 60
- `hours`: 60 minutes = 3600
- `days`: 24 hours = 86400
- `weeks`: 7 days = 604800



## 6.引用类型

### 6.1.数组

嗯，这个可以说比较熟悉了，就是用来储存一组数据的。

- 固定长度

  ```solidity
  // 固定长度 Array
  // 类型[长度] 变量名
  uint[8] array1;
  bytes1[5] array2;
  address[100] array3;
  ```

- 可变长度

  ```solidity
  // 跟上面差不多，不写长度就是了
  uint[] array4;
  bytes1[] array5;
  address[] array6;
  ```

  还有个特殊的

  ```solidity
  // 就是他比较特殊，不用写[]，也不能写 byte[]，可以使用bytes或bytes1[]。bytes 比 bytes1[] 省gas。	
  bytes array7;
  ```

### 6.2.创建数组的规则

- 对于`memory`修饰的动态数组(可变数组)，可以用`new`操作符来创建，但是必须声明长度，并且声明后长度不能改变。

  ```solidity
  // memory动态数组
  uint[] memory array8 = new uint[](5);
  bytes memory array9 = new bytes(9);
  ```

- 这一点简单来说就是`Solidity`会自动判断数组的类型

  ```solidity
  // 会自动判断为 uint8 的数组
  [1,2,3]
  // 如果
  [uint(1),2,3]
  ```

- 如果创建的是动态数组，需要一个一个元素的赋值

  ```solidity
  uint[] memory x = new uint[](3);
  x[0] = 1;
  x[1] = 3;
  x[2] = 4;
  ```

### 6.3.数组方法

官方文档把这个叫做数组成员。。。我都无语了

- `length`: 数组有一个包含元素数量的`length`成员，`memory`数组的长度在创建后是固定的。
- `push()`: `动态数组`拥有`push()`成员，可以在数组最后添加一个`0`元素，并返回该元素的引用。
- `push(x)`: `动态数组`拥有`push(x)`成员，可以在数组最后添加一个`x`元素。
- `pop()`: `动态数组`拥有`pop()`成员，可以移除数组最后一个元素。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

contract HelloWeb3 {

    uint[] array1; 
    function arrayPush() public returns (uint[] memory){
        uint[2] memory a = [uint(1),2];
        array1 = a;
        array1.push(3);
        return  array1;
    }
}
```



### 6.4.结构体

这个熟悉来了，这个和类差不多。

```solidity
// 结构体
struct Student{
    uint256 id;
    uint256 score; 
}

Student student; // 初始一个student结构体，和类的实例化很像了
```

给结构体赋值的几种方法，一把梭哈：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

contract HelloWeb3 {
    struct Student{
        uint256 id;
        uint256 score; 
    }
    // 初始化一个student
    Student student;

    // 方法1:在函数中创建一个storage的struct引用
    function initStudent1() external{
        Student storage _student = student; 
        _student.id = 11;
        _student.score = 100;
    }
    // 方法2:直接引用状态变量的struct 感觉这种方式比较简单吧
    function initStudent2() external{
        student.id = 1;
        student.score = 80;
    }
    // 方法3:构造函数式
    function initStudent3() external {
        student = Student(3, 90);
    }
    // 方法4:key value
    function initStudent4() external {
        student = Student({id: 4, score: 60});
    }
}
```



